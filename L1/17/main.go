package main

import "fmt"

func binarySearch(a []int, search int) int {
	mid := len(a) / 2
	var result int// индекс искомого элемента
	switch {
	case len(a) == 0:
		result = -1 // если мы уже совершили все итерации, но не нашли нужного элемента
					// вернем отрицательный индекс массива, остановим рекурсию
	case a[mid] > search:
		result = binarySearch(a[:mid], search)// опять же рекурсивный вызов, как и в 16 задаче
											// в этом случае мы продолжаем поиск в первый половине массива
	case a[mid] < search:
		result = binarySearch(a[mid+1:], search)// тут мы ищем во второй половине массива
		if result >= 0 { // если такой элемент вообще существует
			result += mid + 1// поскольку индекс половинчатого массива будет считаться от начала половинчатого массива,
							// значение индекса будет акуальным лишь для малого массива, для того чтобы привести
							// индекс малого массива к индексу нашего изначального массива, мы будем суммировать
		}					// индекс середины половинчатого массива к индексу общего массива всякий раз, когда
							// углубляемся в рекурсию и получаем значение искомого, большее чем значение нашей серединки
							// если же у нас значение середины получилось больше, чем искомое, то все проще:
							// будем искать в первой половине, а значит значения с индексами половинчатого массива совпадают
							// со значениями индекса изначального массива, и нам не нужно приводить индексацию малого
							// массива к индексации большего массива

	default: // соответствует случаю, когда мы нашли нужный элемент, конец рекурсии
		result = mid
	}
	return result
}

func main() {
	arr := []int{1, 5, 8, 9, 16, 56, 77, 89, 111, 150}
	result := binarySearch(arr, 77)
	fmt.Println(result)
}
